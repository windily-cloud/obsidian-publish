import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as t,c as o,e as a}from"./app.887b133c.js";const i={},r=a('<h1 id="chap3-paradigm-overview-\u7F16\u7A0B\u8303\u5F0F\u603B\u89C8" tabindex="-1"><a class="header-anchor" href="#chap3-paradigm-overview-\u7F16\u7A0B\u8303\u5F0F\u603B\u89C8" aria-hidden="true">#</a> Chap3. PARADIGM OVERVIEW \u7F16\u7A0B\u8303\u5F0F\u603B\u89C8</h1><p>The three paradigms included in this overview chapter are structured programming, object-orient programming, and functional programming.</p><blockquote><p>\u672C\u7AE0\u5C06\u8BB2\u8FF0\u4E09\u4E2A\u7F16\u7A0B\u8303\u5F0F\uFF0C\u5B83\u4EEC\u5206\u522B\u662F\u7ED3\u6784\u5316\u7F16\u7A0B\uFF08structured programming\uFF09\u3001 \u9762\u5411\u5BF9\u8C61\u7F16\u7A0B\uFF08object-oriented programming\uFF09\u4EE5\u53CA\u51FD\u6570\u5F0F\u7F16\u7A0B\uFF08functional programming\uFF09\u3002</p></blockquote><h2 id="structured-programming-\u7ED3\u6784\u5316\u7F16\u7A0B" tabindex="-1"><a class="header-anchor" href="#structured-programming-\u7ED3\u6784\u5316\u7F16\u7A0B" aria-hidden="true">#</a> STRUCTURED PROGRAMMING \u7ED3\u6784\u5316\u7F16\u7A0B</h2><p>The first paradigm to be adopted (but not the first to be invented) was structured programming, which was discovered by Edsger Wybe Dijkstra in 1968. Dijkstra showed that the use of unrestrained jumps (goto statements) is harmful to program structure. As we\u2019ll see in the chapters that follow, he replaced those jumps with the more familiar if/then/else and do/while/until constructs.</p><blockquote><p>\u7ED3\u6784\u5316\u7F16\u7A0B\u662F\u7B2C\u4E00\u4E2A\u666E\u904D\u88AB\u91C7\u7528\u7684\u7F16\u7A0B\u8303\u5F0F\uFF08\u4F46\u662F\u5374\u4E0D\u662F\u7B2C\u4E00\u4E2A\u88AB\u63D0\u51FA\u7684\uFF09\uFF0C\u7531 Edsger Wybe Dijkstra \u4E8E 1968 \u5E74\u6700\u5148\u63D0\u51FA\u3002\u4E0E\u6B64\u540C\u65F6\uFF0CDijkstra \u8FD8\u8BBA\u8BC1\u4E86\u4F7F\u7528 goto \u8FD9\u6837\u7684\u65E0\u9650\u5236\u8DF3\u8F6C\u8BED\u53E5\u5C06\u4F1A\u635F\u5BB3\u7A0B\u5E8F\u7684\u6574\u4F53\u7ED3\u6784\u3002\u63A5\u4E0B\u6765\u7684\u7AE0\u8282\u6211\u4EEC\u8FD8\u4F1A\u8BF4\u5230\uFF0C\u4E8C\u662F\u8FD9\u4F4D Dijkstra \u6700\u5148\u4E3B\u5F20\u7528\u6211\u4EEC\u73B0\u5728\u719F\u77E5\u7684 if/then/else \u8BED\u53E5\u548C do/while/until \u8BED\u53E5\u6765\u4EE3\u66FF\u8DF3\u8F6C\u8BED\u53E5\u7684\u3002</p></blockquote><p>We can summarize the structured programming paradigm as follows:</p><blockquote><p>\u6211\u4EEC\u53EF\u4EE5\u5C06\u7ED3\u6784\u5316\u7F16\u7A0B\u8303\u5F0F\u5F52\u7ED3\u4E3A\u4E00\u53E5\u8BDD\uFF1A</p></blockquote><p>Structured programming imposes discipline on direct transfer of control.</p><blockquote><p>\u7ED3\u6784\u5316\u7F16\u7A0B\u5BF9\u7A0B\u5E8F\u63A7\u5236\u6743\u7684\u76F4\u63A5\u8F6C\u79FB\u8FDB\u884C\u4E86\u9650\u5236\u548C\u89C4\u8303\u3002</p></blockquote><h2 id="object-oriented-programming-\u9762\u5411\u5BF9\u8C61\u7F16\u7A0B" tabindex="-1"><a class="header-anchor" href="#object-oriented-programming-\u9762\u5411\u5BF9\u8C61\u7F16\u7A0B" aria-hidden="true">#</a> OBJECT-ORIENTED PROGRAMMING \u9762\u5411\u5BF9\u8C61\u7F16\u7A0B</h2><p>The second paradigm to be adopted was actually discovered two years earlier, in 1966, by Ole Johan Dahl and Kristen Nygaard. These two programmers noticed that the function call stack frame in the ALGOL language could be moved to a heap, thereby allowing local variables declared by a function to exist long after the function returned. The function became a constructor for a class, the local variables became instance variables, and the nested functions became methods. This led inevitably to the discovery of polymorphism through the disciplined use of function pointers.</p><blockquote><p>\u8BF4\u5230\u7F16\u7A0B\u9886\u57DF\u4E2D\u7B2C\u4E8C\u4E2A\u88AB\u5E7F\u6CDB\u91C7\u7528\u7684\u7F16\u7A0B\u8303\u5F0F\uFF0C\u5F53\u7136\u5C31\u662F\u9762\u5411\u5BF9\u8C61\u7F16\u7A0B\u4E86\uFF1A\u4E8B\u5B9E\u4E0A\uFF0C\u8FD9\u4E2A\u7F16\u7A0B\u8303\u5F0F\u7684\u63D0\u51FA\u6BD4\u7ED3\u6784\u5316\u7F16\u7A0B\u8FD8\u65E9\u4E86\u4E24\u5E74\uFF0C\u662F\u5728 1966 \u5E74\u7531 Ole Johan Dahl \u548C Kriste Nygaard \u5728\u8BBA\u6587\u4E2D\u603B\u7ED3\u5F52\u7EB3\u51FA\u6765\u7684\u3002\u8FD9\u4E24\u4E2A\u7A0B\u5E8F\u5458\u6CE8\u610F\u5230\u5728 ALGOL \u8BED\u8A00\u4E2D. \u51FD\u6570\u8C03\u7528\u5806\u6808\uFF08call stack frame\uFF09\u53EF\u4EE5\u88AB\u632A\u5230\u5806\u5185\u5B58\u533A\u57DF\u91CC\uFF0C\u8FD9\u6837\u51FD\u6570\u5B9A\u4E49\u7684\u672C\u5730\u53D8\u91CF\u5C31\u53EF\u4EE5\u5728\u51FD\u6570\u8FD4\u56DE\u4E4B\u540E\u7EE7\u7EED\u5B58\u5728\u3002\u8FD9\u4E2A\u51FD\u6570\u5C31\u6210\u4E3A\u4E86\u4E00\u4E2A\u7C7B\uFF08class\uFF09\u7684\u6784\u9020\u51FD\u6570\uFF0C\u800C\u5B83\u6240\u5B9A\u4E49\u7684\u672C\u5730\u53D8\u91CF\u5C31\u662F\u7C7B\u7684\u6210\u5458\u53D8\u91CF\uFF0C\u6784\u9020\u51FD\u6570\u5B9A\u4E49\u7684\u5D4C\u5957\u51FD\u6570\u5C31\u6210\u4E3A\u4E86\u6210\u5458\u65B9\u6CD5\uFF08method\uFF09\u3002\u8FD9\u6837\u4E00\u6765\uFF0C\u6211\u4EEC\u5C31\u53EF\u4EE5\u5229\u7528\u591A\u6001\uFF08polymorphism\uFF09\u6765\u9650\u5236\u7528\u6237\u5BF9\u51FD\u6570\u6307\u9488\u7684\u4F7F\u7528\u3002</p></blockquote><p>We can summarize the object-oriented programming paradigm as follows:</p><blockquote><p>\u5728\u8FD9\u91CC\uFF0C\u6211\u4EEC\u4E5F\u53EF\u4EE5\u7528\u4E00\u53E5\u8BDD\u6765\u603B\u7ED3\u9762\u5411\u5BF9\u8C61\u7F16\u7A0B\uFF1A</p></blockquote><p>Object-oriented programming imposes discipline on indirect transfer of control.</p><blockquote><p>\u9762\u5411\u5BF9\u8C61\u7F16\u7A0B\u5BF9\u7A0B\u5E8F\u63A7\u5236\u6743\u7684\u95F4\u63A5\u8F6C\u79FB\u8FDB\u884C\u4E86\u9650\u5236\u548C\u89C4\u8303\u3002</p></blockquote><h2 id="functional-programming-\u51FD\u6570\u5F0F\u7F16\u7A0B" tabindex="-1"><a class="header-anchor" href="#functional-programming-\u51FD\u6570\u5F0F\u7F16\u7A0B" aria-hidden="true">#</a> FUNCTIONAL PROGRAMMING \u51FD\u6570\u5F0F\u7F16\u7A0B</h2><p>The third paradigm, which has only recently begun to be adopted, was the first to be invented. Indeed, its invention predates computer programming itself. Functional programming is the direct result of the work of Alonzo Church, who in 1936 invented l-calculus while pursuing the same mathematical problem that was motivating Alan Turing at the same time. His l-calculus is the foundation of the LISP language, invented in 1958 by John McCarthy. A foundational notion of l-calculus is immutability\u2014that is, the notion that the values of symbols do not change. This effectively means that a functional language has no assignment statement. Most functional languages do, in fact, have some means to alter the value of a variable, but only under very strict discipline.</p><blockquote><p>\u5C3D\u7BA1\u7B2C\u4E09\u4E2A\u7F16\u7A0B\u8303\u5F0F\u662F\u8FD1\u4E9B\u5E74\u624D\u521A\u521A\u5F00\u59CB\u88AB\u91C7\u7528\u7684\uFF0C\u4F46\u5B83\u5176\u5B9E\u662F\u4E09\u4E2A\u8303\u5F0F\u4E2D\u6700\u5148\u88AB\u53D1\u660E\u7684\u3002\u4E8B\u5B9E\u4E0A\uFF0C\u51FD\u6570\u5F0F\u7F16\u7A0B\u6982\u5FF5\u662F\u57FA\u4E8E\u4E0E\u963F\u5170\xB7\u56FE\u7075\u540C\u65F6\u4EE3\u7684\u6570\u5B66\u5BB6 Alonzo Church \u5728 1936 \u5E74\u53D1\u660E\u7684\u5165\u6F14\u7B97\u7684\u76F4\u63A5\u884D\u751F\u7269\u30021958 \u5E74 John Mccarthy \u5229\u7528\u5176\u4F5C\u4E3A\u57FA\u7840\u53D1\u660E\u4E86 LISP \u8BED\u8A00\u3002\u4F17\u6240\u5468\u77E5\uFF0C\u03BB \u6F14\u7B97\u6CD5\u7684\u4E00\u4E2A\u6838\u5FC3\u601D\u60F3\u662F\u4E0D\u53EF\u53D8\u6027\u2014\u2014\u67D0\u4E2A\u7B26\u53F7\u6240\u5BF9\u5E94\u7684\u503C\u662F\u6C38\u8FDC\u4E0D\u53D8\u7684\uFF0C\u6240\u4EE5\u4ECE\u7406\u8BBA\u4E0A\u6765\u8BF4\uFF0C\u51FD\u6570\u5F0F\u7F16\u7A0B\u8BED\u8A00\u4E2D\u5E94\u8BE5\u662F\u6CA1\u6709\u8D4B\u503C\u8BED\u53E5\u7684\u3002\u5927\u90E8\u5206\u51FD\u6570\u5F0F\u7F16\u7A0B\u8BED\u8A00\u53EA\u5141\u8BB8\u5728\u975E\u5E38\u4E25\u683C\u7684\u9650\u5236\u6761\u4EF6\u4E0B\uFF0C\u624D\u53EF\u4EE5\u66F4\u6539\u67D0\u4E2A\u53D8\u91CF\u7684\u503C\u3002</p></blockquote><p>We can summarize the functional programming paradigm as follows:</p><blockquote><p>\u56E0\u6B64\uFF0C\u6211\u4EEC\u5728\u8FD9\u91CC\u53EF\u4EE5\u5C06\u51FD\u6570\u5F0F\u7F16\u7A0B\u8303\u5F0F\u603B\u7ED3\u4E3A\u4E0B\u9762\u8FD9\u53E5\u8BDD\uFF1A</p></blockquote><p>Functional programming imposes discipline upon assignment.</p><blockquote><p>\u51FD\u6570\u5F0F\u7F16\u7A0B\u5BF9\u7A0B\u5E8F\u4E2D\u7684\u8D4B\u503C\u8FDB\u884C\u4E86\u9650\u5236\u548C\u89C4\u8303\u3002</p></blockquote><h2 id="food-for-thought-\u4EC5\u4F9B\u601D\u8003" tabindex="-1"><a class="header-anchor" href="#food-for-thought-\u4EC5\u4F9B\u601D\u8003" aria-hidden="true">#</a> FOOD FOR THOUGHT \u4EC5\u4F9B\u601D\u8003</h2><p>Notice the pattern that I\u2019ve quite deliberately set up in introducing these three programming paradigms: Each of the paradigms removes capabilities from the programmer. None of them adds new capabilities. Each imposes some kind of extra discipline that is negative in its intent. The paradigms tell us what not to do, more than they tell us what to do.</p><blockquote><p>\u5982\u4F60\u6240\u89C1\uFF0C\u6211\u5728\u4ECB\u7ECD\u4E09\u4E2A\u7F16\u7A0B\u8303\u5F0F\u7684\u65F6\u5019\uFF0C\u6709\u610F\u91C7\u7528\u4E86\u4E0A\u9762\u8FD9\u79CD\u683C\u5F0F\uFF0C\u76EE\u7684\u662F\u51F8\u663E\u6BCF\u4E2A\u7F16\u7A0B\u8303\u5F0F\u7684\u5B9E\u9645\u542B\u4E49\u2014\u2014\u5B83\u4EEC\u90FD\u4ECE\u67D0\u4E00\u65B9\u9762\u9650\u5236\u548C\u89C4\u8303\u4E86\u7A0B\u5E8F\u5458\u7684\u80FD\u529B\u3002\u6CA1\u6709\u4E00\u4E2A\u8303\u5F0F\u662F\u589E\u52A0\u65B0\u80FD\u529B\u7684\u3002\u4E5F\u5C31\u662F\u8BF4\uFF0C\u6BCF\u4E2A\u7F16\u7A0B\u8303\u5F0F\u7684\u76EE\u7684\u90FD\u662F\u8BBE\u7F6E\u9650\u5236\u3002\u8FD9\u4E9B\u8303\u5F0F\u4E3B\u8981\u662F\u4E3A\u4E86\u544A\u8BC9\u6211\u4EEC\u4E0D\u80FD\u505A\u4EC0\u4E48\uFF0C\u800C\u4E0D\u662F\u53EF\u4EE5\u505A\u4EC0\u4E48\u3002</p></blockquote><p>Another way to look at this issue is to recognize that each paradigm takes something away from us. The three paradigms together remove goto statements, function pointers, and assignment. Is there anything left to take away?</p><blockquote><p>\u53E6\u5916\uFF0C\u6211\u4EEC\u5E94\u8BE5\u8BA4\u8BC6\u5230\uFF0C\u8FD9\u4E09\u4E2A\u7F16\u7A0B\u8303\u5F0F\u5206\u522B\u9650\u5236\u4E86 goto \u8BED\u53E5\u3001\u51FD\u6570\u6307\u9488\u548C\u8D4B\u503C\u8BED\u53E5\u7684\u4F7F\u7528\u3002\u90A3\u4E48\u9664\u6B64\u4E4B\u5916\uFF0C\u8FD8\u6709\u4EC0\u4E48\u53EF\u4EE5\u53BB\u9664\u7684\u5417\uFF1F</p></blockquote><p>Probably not. Thus these three paradigms are likely to be the only three we will see\u2014at least the only three that are negative. Further evidence that there are no more such paradigms is that they were all discovered within the ten years between 1958 and 1968. In the many decades that have followed, no new paradigms have been added.</p><blockquote><p>\u53EF\u80FD\u6CA1\u6709\u4E86\u3002\u56E0\u6B64\u8FD9\u4E09\u4E2A\u7F16\u7A0B\u8303\u5F0F\u53EF\u80FD\u662F\u4EC5\u6709\u7684\u4E09\u4E2A\u4E86\u2014\u2014\u5982\u679C\u5355\u8BBA\u53BB\u9664\u80FD\u529B\u7684\u7F16\u7A0B\u8303\u5F0F\u7684\u8BDD\u3002\u652F\u6491\u8FD9\u4E00\u7ED3\u8BBA\u7684\u53E6\u5916\u4E00\u4E2A\u8BC1\u636E\u662F\uFF0C\u4E09\u4E2A\u7F16\u7A0B\u8303\u5F0F\u90FD\u662F\u5728 1958 \u5E74\u5230 1968 \u5E74\u8FD9 10 \u5E74\u95F4\u88AB\u63D0\u51FA\u6765\u7684\uFF0C\u540E\u7EED\u518D\u4E5F\u6CA1\u6709\u65B0\u7684\u7F16\u7A0B\u8303\u5F0F\u51FA\u73B0\u8FC7\u3002</p></blockquote><h2 id="conclusion-\u672C\u7AE0\u5C0F\u7ED3" tabindex="-1"><a class="header-anchor" href="#conclusion-\u672C\u7AE0\u5C0F\u7ED3" aria-hidden="true">#</a> CONCLUSION \u672C\u7AE0\u5C0F\u7ED3</h2><p>What does this history lesson on paradigms have to do with architecture? Everything. We use polymorphism as the mechanism to cross architectural boundaries; we use functional programming to impose discipline on the location of and access to data; and we use structured programming as the algorithmic foundation of our modules.</p><blockquote><p>\u5927\u5BB6\u53EF\u80FD\u4F1A\u95EE\uFF0C\u8FD9\u4E9B\u7F16\u7A0B\u8303\u5F0F\u7684\u5386\u53F2\u77E5\u8BC6\u4E0E\u8F6F\u4EF6\u67B6\u6784\u6709\u5173\u7CFB\u5417\uFF1F\u5F53\u7136\u6709\uFF0C\u800C\u76EE\u5173\u7CFB\u76F8\u5F53\u5BC6\u5207\u3002\u8B6C\u5982\u8BF4\uFF0C\u591A\u6001\u662F\u6211\u4EEC\u8DE8\u8D8A\u67B6\u6784\u8FB9\u754C\u7684\u624B\u6BB5\uFF0C\u51FD\u6570\u5F0F\u7F16\u7A0B\u662F\u6211\u4EEC\u89C4\u8303\u548C\u9650\u5236\u6570\u636E\u5B58\u653E\u4F4D\u7F6E\u4E0E\u8BBF\u95EE\u6743\u9650\u7684\u624B\u6BB5\uFF0C\u7ED3\u6784\u5316\u7F16\u7A0B\u5219\u662F\u5404\u6A21\u5757\u7684\u7B97\u6CD5\u5B9E\u73B0\u57FA\u7840\u3002</p></blockquote><p>Notice how well those three align with the three big concerns of architecture: function, separation of components, and data management.</p><blockquote><p>\u8FD9\u548C\u8F6F\u4EF6\u67B6\u6784\u7684\u4E09\u5927\u5173\u6CE8\u91CD\u70B9\u4E0D\u8C0B\u800C\u5408\uFF1A\u529F\u80FD\u6027\u3001\u7EC4\u4EF6\u72EC\u7ACB\u6027\u4EE5\u53CA\u6570\u636E\u7BA1\u7406\u3002</p></blockquote>',36),n=[r];function s(h,c){return t(),o("div",null,n)}const p=e(i,[["render",s],["__file","ch3.html.vue"]]);export{p as default};
